1.复杂度
   衡量算法好坏的时候，两个主要维度（时间|空间）
   复杂度衡量算法好快的一个刻度尺/标准
    1.时间复杂度     2.空间复杂度
2.时间复杂度
    第一反应：算法的运行时间
    因为运行环境的不确定，所以直接拿运行时间去衡量不合理
    CPU主频         单位时间内，运行的指令个数
    CPU每秒运行的指令个数是不变的
    
   考察算法的运行时间   考察算法运行需要的指令个数
   算法运行的指令个数和因素（数据规模n）有关系
   冒泡排序（10/10000）
   指令个数 = F（n）
   所以：
        1.时间复杂度，求F（n）
    大O渐进表示法（不求甚解的过程）
      已知F（n）= n^2 + 2*n + 10
      1.只保留最高次项
      2.最高次的项的系数化为1
      O(F(n)) = O(n^2)
3.算法有多种情况需要考察
最好              平均            最坏
O(1)             O(n)             O(n)
考察算法的复杂度，一般来说只关注的情况
 
 void bubbleSort(int[] array)      //冒泡排序
{
   //TODO；
}
n - 1 + n - 2 + ... + 1 + 0
n
(n - 1)*n/2 
//前提是，array已经有序
//找到key所在下标，没找到，返回-1
public static int binarySearch(int[] array,int key){
}

