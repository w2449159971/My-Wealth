二分查找，最快情况，没找到
上次： 区间内   1个数
再上：          2个数
在上：          4个数

n             1024(1000)      100万         10亿
O(n)          1024(1000)      100万         10亿
O(logn)       10              20            30
常见的时间复杂度
O(1)
O(log(n))       稍难
O(n*log(n))  
O(n^2)

long fac(int n){
        if(n<2)
        return n;
        }
     return fac(n-1)*n;
    }
  O(n)
  
  long fib(int n){
     if(n<2){
       return n;
       }
      return fib(n-1)+fib(n-2);
     }
 结论：时间复杂度就是计算结点个数 
fib(50)
约等于2^50/计算机主频
结论：如果一个算法是O(2^n),这算法没有用

空间复杂度
    算法执行过程中，占用的额外空间和数据规模n的关系的大O渐进标识符
    开辟空间：
    1.栈上的局部变量/形参
    2.堆上的对象(数组、其他对象)
    3.如果是递归方法，考虑调用栈的占用情况
 总结：复杂度
    衡量算法好坏的刻度，有两个维度
    时间复杂度  1.通过算法使用的指令个数衡量
    空间复杂度
    大O渐进表示法 1.最高项保留 2.系数=1
 常见的复杂度
 O(1)   O(log(n))  O(n)   O(n*log(n))  O(n^2)
 二分查找(包含完全二叉树)  O(log(n))
 递归：考虑调用栈 
 
 
 
 
